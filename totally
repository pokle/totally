#!/usr/bin/env bash
#
# Totally is inspired by Leiningen, Heroku, swimming pools, and licenced
# under the GPLv2.
#
#   Copyright (C) 2014 Tushar Pokle
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


#
# Logging, error handling
((ERRORS=0))
function error() { ((ERRORS++)); echo ERROR: $@ >&2; }
function die() { error $@; exit 1; }
function log() { :; } # Turned off by default - use the verbose command to turn on
function cmd_verbose() {
    function log() { echo $@ >&2; }
    set -x
    log increased verbosity
}

function usage() {
    cat <<-USAGE  >&2 
		usage: $0 COMMAND...

		Main commands
		-------------
		 init        Creates a new project in the current directory
		 run         Builds and restarts your app
		 tunnel      Tunnels all app's exposed ports to your computer

		Troubleshooting commands
		------------------------
		 config       Show Totally configuration
		 logs         Tails the console
		 destroy      Stops the container, and deletes it - losing data
		 restart      Destroys and starts the container with the latest image
		 inspect ARGS Shows you information about your container
		 top          Shows running processes  
		 ps 	      Same as top

		Ninja commands
		--------------
		 interactive ARGS Like run, but drops you into the container.
		                  Try: totally interactive bash
		                  Or even: totally build interactive bash

		Auxilliary commands
		-------------------
		 verbose 	  For eg. a verbose build: 'totally verbose build'
		 build   	  Builds a Docker image

		Configuration
		-------------
		 NAME            Your project name
		 DOCKER_SSH_HOST A host to build and run your app on
		 REMOTE_ROOT     The temp. dir. on DOCKER_SSH_HOST to build in
		 TUNNEL_PORT     A base port number for your tunnels
		 IMAGE           The name of the Docker image that will be built
		 CONTAINER       The name of the Docker container to run your app as

		Chaining commands
		-----------------
		Most commands can be chained. Eg. 'totally run logs' runs your app, and
		then tails the logs. Commands that take arguments like inspect can be
		chained only if they are the last command called. 
		For eg. totally run inspect --format '{{.NetworkSettings.IPAddress}}'

	USAGE
    exit 1
}

function cmd_init() {
    [ -f .totally ] && die "This directory has already been initialised. 'cat .totally' to see your project."

    local BUILD_DIR=$(find . -name Dockerfile | head -1 | xargs dirname)

    if [ -z "$BUILD_DIR" ]; then
        BUILD_DIR=.
        log "Creating a quick start Dockerfile - please edit"
        cat >Dockerfile <<-HERE
			FROM tianon/centos:6.5
			ADD . /app
			WORKDIR /app
			EXPOSE 8000
			CMD python -m SimpleHTTPServer 8000
		HERE
    fi

    local name=$(basename $PWD)
    cat > .totally <<-HERE
		NAME="$name"
		BUILD_DIR="$BUILD_DIR"
		IMAGE="\$NAME:latest"
		CONTAINER="\$USER-\$NAME"
		TUNNEL_PORT=12000
	HERE

    echo Initialised new Totally project called $name
    exit 0
}

# Recurses up from the current directory all the way to the root
# directory looking for .totally files to source for configuration overrides
# Also sets LOCAL_ROOT - which should be the local project root
function configuration_walk() {
    if [ "/" != "$PWD" ]; then
        pushd .. >/dev/null
        configuration_walk
        popd >/dev/null
    fi
    
    [ -r $PWD/.totally ] && 
        log "Sourcing overrides from $PWD/.totally" && 
        source $PWD/.totally &&
        LOCAL_ROOT=$PWD # The last recursed $PWD should be the local project root
}

function validate() {
    [ -z "$DOCKER_SSH_HOST" ] && error "Missing docker host name env DOCKER_SSH_HOST"
    [ -z "$NAME" ] && error "Missing project name env: NAME" 
    [ -z "$IMAGE" ] && error "Missing Docker image env: IMAGE" 
    [ -z "$CONTAINER" ] && error "Missing Docker container name env: CONTAINER"

    [ ! -f "$LOCAL_ROOT/$BUILD_DIR/Dockerfile" ] && error "Missing a Dockerfile at $LOCAL_ROOT/$BUILD_DIR."

    (( ERRORS > 0 )) && 
        die "Perhaps did you forget to run totally init?"
}

function cmd_config() {
    cat <<-HERE
		# Project
		NAME=$NAME
		BUILD_DIR=$BUILD_DIR
		TUNNEL_PORT=$TUNNEL_PORT

		# Docker
		IMAGE=$IMAGE
		CONTAINER=$CONTAINER

		# Docker host
		DOCKER_SSH_HOST=$DOCKER_SSH_HOST
		REMOTE_ROOT=$REMOTE_ROOT
	HERE
}

function configure() {
    if [ -r ~/.totally ]; then 
        source ~/.totally
    fi
    
    configuration_walk $PWD

    # Defaults
    REMOTE_ROOT=${REMOTE_ROOT:-totally-build}
    TUNNEL_PORT=${TUNNEL_PORT:-20000}
    BUILD_DIR=${BUILD_DIR:-.}

    validate
}

#
# The main commands
#


function cmd_sync() {
    echo -- Sync\'ing to $DOCKER_SSH_HOST
    ssh $DOCKER_SSH_HOST "mkdir -p '$REMOTE_ROOT'"
    rsync --archive --delete $LOCAL_ROOT/$BUILD_DIR/ $DOCKER_SSH_HOST:$REMOTE_ROOT/$NAME/
}

function cmd_destroy() {
     ssh -t $DOCKER_SSH_HOST "
        function container_exists() { docker inspect --format '.' $CONTAINER > /dev/null 2>&1; }

        container_exists &&
            echo -n 'Stopping ' && 
            docker stop $CONTAINER &&
            echo -n 'Removing ' &&
            docker rm $CONTAINER" &&
    echo -- Destroyed $CONTAINER
}

function cmd_restart() {

    cmd_destroy  # Best effort. Don't care if it fails

    ssh -t $DOCKER_SSH_HOST "
		echo -n '-- Running $CONTAINER id '
		docker run --name $CONTAINER -d $IMAGE &&
	    echo -- SUCCESS. Run 'totally logs' to watch startup
	"
}

function cmd_build() {
    cmd_sync &&
    echo -- Building Docker image called $IMAGE on $DOCKER_SSH_HOST &&
    ssh $DOCKER_SSH_HOST "cd $REMOTE_ROOT/$NAME && docker build -t $IMAGE ." &&
    echo -- Build successful
}

function cmd_run() {
    cmd_build &&
    cmd_restart
}

function cmd_interactive() {
    ssh -t $DOCKER_SSH_HOST "docker run --rm -i -t $IMAGE $@"
    exit $? # No more commands allowed, because we consume $@
}



#
# Troubleshooting commands
function cmd_top()  { ssh $DOCKER_SSH_HOST "docker top $CONTAINER"; }
function cmd_ps() { cmd_top; }
function cmd_inspect() { 
    ssh $DOCKER_SSH_HOST docker inspect $@ $CONTAINER; 
    exit $? # No more commands allowed, because we consume $@
}

function cmd_logs() {
    ssh $DOCKER_SSH_HOST "
        echo -- Tailing logs for $CONTAINER. Hit ^C to stop
        while true; do
            docker logs --follow $CONTAINER 
            echo
            echo -- Restarting totally logs at $(date) ------ Hit ^C to stop -----------
            sleep 2
        done
    "
}

# Just so that you can be poetic - 'totally run man'
function cmd_man() { :; }

function cmd_tunnel() {
    local container_ip=$(ssh $DOCKER_SSH_HOST "docker inspect --format='{{.NetworkSettings.IPAddress}}' $CONTAINER")
    [ -z "$container_ip" ] && 
        die "-- Can't get the IP address of your container. Is it running?"

    local container_ports=$(ssh $DOCKER_SSH_HOST "docker inspect --format='{{range \$p,\$c := .NetworkSettings.Ports}}{{\$p}},{{end}}' $CONTAINER | sed 's/\/tcp,/ /g'")
    [ -z "$container_ports" ] &&
        die "-- Sorry, no TCP container ports were found. Did you EXPOSE ports in your Dockerfile?"

    local container_port
    local tunnels

    for container_port in $container_ports; do
        echo "-- Tunneling localhost:$TUNNEL_PORT => $DOCKER_SSH_HOST => $container_ip:$container_port. Got HTTP? http://localhost:$TUNNEL_PORT/"
        tunnels="$tunnels -L $((TUNNEL_PORT++)):$container_ip:$container_port"
    done

    ssh $tunnels $DOCKER_SSH_HOST 'echo -- Press ^C to close tunnel; sleep 3600'
}

function is_function() {
    [ "$( type -t $1 )" = "function" ]
}

function is_function() {
    [ "$( type -t $1 )" = "function" ]
}

function command_loop() {
    [ $# = 0 ] && usage

    # init needs to run before configure because it bootstraps configure
    if [ "init" = "$1" ]; then
        cmd_init
        shift
    fi

    configure

    until [ $# = 0 ]; do
        CMD=$1; shift
        if is_function cmd_$CMD; then
            cmd_$CMD $@ || die "Oops! $CMD exited with $?"
        else
            error Sorry, no such command $CMD
            usage
        fi
    done
}

if [ -z "$TOTALLY_TEST_MODE" ]; then
    command_loop $@
else
    true # Required so that the tests can source this file
fi
